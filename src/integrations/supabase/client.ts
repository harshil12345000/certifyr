// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://mkewllzuprwkyovjtymj.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1rZXdsbHp1cHJ3a3lvdmp0eW1qIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDY4NTI2MTQsImV4cCI6MjA2MjQyODYxNH0.MR2MmGROQAw3Ah7RqgxZneCcI_vHs09ZPegLhcoRV1k";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
  }
});

// Helper function to get public URL for a file in storage with effective cache busting
export const getPublicUrl = (bucketName: string, filePath: string) => {
  if (!filePath) return null;
  
  const timestamp = new Date().getTime(); // Add timestamp to prevent caching
  const { data } = supabase.storage.from(bucketName).getPublicUrl(`${filePath}?t=${timestamp}`);
  return data.publicUrl;
};

// Upload file helper function with improved error handling
export const uploadFile = async (bucketName: string, filePath: string, file: File) => {
  try {
    const { data, error } = await supabase.storage
      .from(bucketName)
      .upload(filePath, file, {
        cacheControl: '0', // Set cache control to 0 to prevent browser caching
        upsert: true,
      });
      
    if (error) {
      console.error('Error uploading file:', error);
      throw error;
    }
    
    return getPublicUrl(bucketName, filePath);
  } catch (error) {
    console.error('Upload error:', error);
    throw error;
  }
};

// Upload branding asset helper with improved naming
export const uploadBrandingAsset = async (file: File, assetType: string) => {
  if (!file) return null;
  
  const fileExt = file.name.split('.').pop();
  const fileName = `${assetType}_${Date.now()}.${fileExt}`;
  const filePath = `${assetType}s/${fileName}`;
  
  try {
    const publicUrl = await uploadFile('branding', filePath, file);
    return { fileName, publicUrl };
  } catch (error) {
    console.error(`Error uploading ${assetType}:`, error);
    return null;
  }
};

// Improved function to get the latest branding settings
export const getLatestBrandingSettings = async () => {
  try {
    const { data, error } = await supabase
      .from('branding_settings')
      .select('*')
      .order('created_at', { ascending: false })
      .limit(1);
      
    if (error) throw error;
    return data && data.length > 0 ? data[0] : null;
  } catch (error) {
    console.error('Error getting branding settings:', error);
    return null;
  }
};

// Save branding settings to database with proper updating
export const saveBrandingSettings = async (
  settings: { 
    logo?: string | null; 
    seal?: string | null; 
    letterhead?: string | null; 
    signature?: string | null;
    tagline?: string | null;
  }
) => {
  try {
    // First check if we have existing settings
    const { data: existingSettings } = await supabase
      .from('branding_settings')
      .select('*')
      .order('created_at', { ascending: false })
      .limit(1);
      
    if (existingSettings && existingSettings.length > 0) {
      // Update existing settings - keep existing values if not provided
      const updatedSettings = {
        logo: settings.logo !== undefined ? settings.logo : existingSettings[0].logo,
        seal: settings.seal !== undefined ? settings.seal : existingSettings[0].seal,
        letterhead: settings.letterhead !== undefined ? settings.letterhead : existingSettings[0].letterhead,
        signature: settings.signature !== undefined ? settings.signature : existingSettings[0].signature,
        tagline: settings.tagline !== undefined ? settings.tagline : existingSettings[0].tagline,
      };
      
      const { data, error } = await supabase
        .from('branding_settings')
        .update(updatedSettings)
        .eq('id', existingSettings[0].id)
        .select();
        
      if (error) throw error;
      return data;
    } else {
      // Insert new settings if none exist
      const { data, error } = await supabase
        .from('branding_settings')
        .insert([settings])
        .select();
        
      if (error) throw error;
      return data;
    }
  } catch (error) {
    console.error('Error saving branding settings:', error);
    throw error;
  }
};

// Indian Kanoon API integration
export const generateDocumentFromLegalAPI = async (prompt: string) => {
  try {
    const apiKey = process.env.INDIAN_KANOON_API_KEY;
    
    // For frontend security, we'll call this through a Supabase Edge Function
    // Here, we're just setting up the client-side function that will call the backend
    
    const response = await fetch('/api/generate-legal-document', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ prompt }),
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`API error: ${errorText}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error generating document:', error);
    throw error;
  }
};
